package uk.msci.project.rsa;

import java.security.MessageDigest;
import java.util.Arrays;

/**
 * This class implements the Mask Generation Function 1 (MGF1), a method used for transforming a
 * cryptographic hash function to generate outputs of a desired size i.e., a mask. The
 * Implementation is as per the PKCS#1 v2.2 specification.
 */
public class MGF1 {

  /**
   * The MessageDigest instance used for hashing in the mask generation process. This digest defines
   * the specific hash function to be used in the MGF1 algorithm.
   */
  private final MessageDigest digest;

  /**
   * Constructs an MGF1 instance with a specified hash function.
   *
   * @param digest The MessageDigest instance representing the hash function to be used in MGF1.
   */
  public MGF1(MessageDigest digest) {
    this.digest = digest;
  }

  /**
   * Generates a mask of the specified length using the MGF1 algorithm. The mask is generated by
   * repeatedly hashing a combination of the input seed and an iteration counter until enough data
   * is produced, then truncating or padding the result to the desired length.
   *
   * @param mgfSeed The input seed byte array for the mask generation function.
   * @param maskLen The desired length of the mask in bytes.
   * @return A byte array containing the generated mask.
   */
  public byte[] generateMask(byte[] mgfSeed, int maskLen) {

    int hLen = digest.getDigestLength();
    if (!(maskLen >= 0 && hLen <= Integer.MAX_VALUE && maskLen > 1)) {
      throw new IllegalArgumentException(
          "maskLen must be a valid positive integer");
    }
    if (mgfSeed == null) {
      throw new IllegalArgumentException(
          "Seed value cannot be null");
    }

    // 1. Let T be the empty octet string.
    byte[] mask = new byte[0];
    // 2.  For counter from 0 to \ceil (maskLen / hLen) - 1
    for (int counter = 0; counter < (int) Math.ceil((double) maskLen / hLen); counter++) {
      // a. Convert counter to an octet string C of length 4 octets
      byte[] C = new byte[]{
          (byte) (counter >>> 24),
          (byte) (counter >>> 16),
          (byte) (counter >>> 8),
          (byte) (counter)
      };

      // b. Concatenate the hash of the seed mgfSeed and C to the octet string T
      digest.reset(); // Clear the digest
      // Update the digest with the seed and counter bytes
      digest.update(mgfSeed);
      digest.update(C);
      byte[] hash = digest.digest();

      // Concatenate the hash to the current mask
      mask = Arrays.copyOf(mask, mask.length + hash.length);
      System.arraycopy(hash, 0, mask, mask.length - hash.length, hash.length);
    }
    // 3. Output the leading maskLen octets of T as the octet string mask.
    return Arrays.copyOf(mask, maskLen);
  }

}
